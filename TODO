= Current stack

== GraphViz/TTG

- Baseline for further evaluation of TTG + documentation example for recursion
  schemes with higher-order functors:
    - Add (co)algebras for calculating number of atomic arrows in a free (unsized)
      category.
- Write 'Cat.Sized.Category.Free.TTG' + 'Cat.Sized.Category.Free.GraphViz' +
  update 'Cat.Sized.Arith'.
- Write 'Cat.Sized.Monoidal.Free.TTG' + 'Cat.Sized.Monoidal.Free.GraphViz' +
  variants for 'Braided' and 'Cartesian' + update 'Cat.Sized.Circuit'.
- Consider some way of refactoring the proliferation of 'TTG' ± 'GraphViz'
  modules
    — Could a variation on "type-aligned sequences" generalize across
      classes?
    - Would a datatypes-a-la-carte products-of-functors approach generalize
      better/increase code reuse compared to TTG?

== Finish tensors

- instance SrN Monoidal...

- Propagate instances for Sr2:

  - Either move monadic (nested product) combinators to a subclass (refactoring
    headache with low apparent value right now), or shove 'Sr2' into its own
    module as it is, because 'SrN' ought to do everything 'Sr2' can and 'Sr2'
    is just a development stepping-stone to something like 'SrN'.


= Anytime dead code cleanup/maintenance

  - Cat.Orthotope

  - Cat.Unsized.Category.Free.Data - cleanup @foldMap@, @fixed@
  - Cat.Sized.Semigroupoid.Free.Data - cleanup @foldMap@
  - Cat.Sized.Category.Free.Data - cleanup @foldMap@
  - Cat.Sized.Monoidal.Free.Data - cleanup @foldMap@
  - Cat.Sized.Braided
  - Cat.Sized.Diagonal



= Foundations / high-value experiments

1. Sort out what the relevant constraints on foldMap should be and make it
consistent across modules for free category types.

2. Bimonoidal
 - Revisit Cat.Sized.Circuit with Cat.Sized.Cartesian.Free
   - Could you actually use Codiagonal ± Semicocartesian methods?
 - DistributiveLR instances
   - R1/VS.Vector
 - Maaaaybe Free Semiadditive (unless in the course of writing it you discover
   Free Additive would be a better use of time?)

3. Sketch a profunctor-based typeclass hierarchy in a new branch when your
   examples include biproducts and enough of the basic functionality with
   biproducts (e.g. recursion schemes) seems to be working.

4. Feature integration / testing:
  - Boolean circuits as tensors over a semiring
    - Consider a numhask reimplementation
  - Recursion scheme over circuits/products of constant boolean morphisms for
    normal forms?
    - Do you need/want different types (and perhaps a different,
      not-just-an-example module) for this?
  - Incremental computation ± traces?
  - Check refs to see what you need to take a beeline to encoding SAT problems
    - Boolean relations
    - ((Self-dual?) compact) closed categories (/dagger categories?)
    - Traces
  - Zusatz: ersatz terms as a DSL.


= Maintenance that might pay dividends

- Refactor: Because of module coupling (currently manifesting with instance
  derivations and obnoxious constraints), move '{Unsized/Sized}.HFunctor' into
  a module separate from '_.Functor'.
    - Expected payoff might increase with the volume/complexity of future code
      that depends on recursion schemes.
      - Example/experiment within reach: GraphViz pretty-printing requires an
        annotation step currently implemented with a (vanilla) state monad over
        the binary tree AST of a free category type; an alternative is an
        effectful anamorphism that ought to be preceded by introducing an
        @HMonad@ class.





= Low priority

- comonad instances for R1 and VS.Vector/TODO stubs
  - non-empty leftmost/rightmost/center comonad for rank ≥ 1 — all defined by a lens that points to a *location* independent of contents
  — instance for any functor over a monoid
  — "search"/"selection" that points to a first/last value satisfying a predicate (or a default)?
  - pointer/finitary representable store comonad
  - tangent bundle/finitary discrete derivative comonad

== Infrastructure

- repository CI / fix cachix setup

- Multi-cradle project:
  - cat-herder
  - cat-herder-test
  - cat-herder-base
  - cat-herder-vector-sized
  - cat-herder-orthotope
